---
title: "Exercise 1"
format: html
---

You must always load the Pmetrics library first.

```{r}
#| eval: true
#| output: false
#library(Pmetrics)
devtools::load_all()
```

# First NPAG run - tlag, ka, kel, vol

### Working directory

You must always tell R where your working directory is going to be. This is the directory where R expects to find files and where it will save output files. You can set your working directory with the `setwd()` function.

Windows users: Make sure that you separate directories with a forward slash "/" or double backslashes "\\". Unfortunately, Windows is the only OS that uses backslashes "", so R conforms to Unix/Linux style with the forward slash. If you copy the example below, make sure to change the path to one that exists on your computer.

```{r}
# change the path to one that exists on your computer
setwd("/path/to/your/project/directory") # Mac and Linux users
setwd("C:/path/to/your/project/directory") # Windows users
```

### Data objects

Pmetrics always needs data and a model to run, so let's create a new data object. We will set the limit of quantification (loq) to 1. See ?PM_data for help.

```{r}
#| eval: true
exData <- PM_data$new(data = "../Examples/src/ex.csv", loq = 1)
```

Here we did execute the code so you can see the output. Pmetrics standardizes the data, checks for errors, and provides an error and attempted fix report fo any found.

You can look at a .csv data file directly by opening it in a spreadsheet program like Excel, or a text editor.

`exData` is an R6 object, which means that contains both data and methods to process that data.

```{r}
exData # prints the object, usually to the terminal, but in this case to a rendered "lite" spreadsheet
exData$data # contains your original data
exData$standard_data # contains the standardized and validated data
exData$summary() # prints the summary of the data to the terminal
```

Most Pmetrics objects are R6 objects, so you can use the `$` operator to access their data and methods. Many of them have a `summary()` method that prints a summary of the object to the console and a `plot()` method that creates a plot of the object. See `?PM_data` for more information on the `PM_data` class and its methods.

**Note:** We recognize that many users are familiar with the "S3 framework" in R, which uses functions like `summary(object)` and `plot(object)`. To comply with better programming standards, Pmetrics uses the R6 framework. However, we have provided S3 methods for most functions, so you can use `summary(object)` and `plot(object)` if you prefer.

```{r}
# S3 method to summarize data
summary(exData)
```

`PM_data` has a `plot()` method that creates a plot of the data. See `?plot.PM_data` for more information.

```{r}
#| eval: true
# piping to plotlygg() turns the interractive plotly plot to a static ggplot2 plot 
exData$plot() %>% plotlygg()
```

We have piped (`%>%`) the plot to `plotlygg()` to convert the interactive plotly plot to a static ggplot2 plot for rendering in this document. You can interact with the plot in your own script or Quarto document. If you're not familiar with the pipe operator, see [this article](https://magrittr.tidyverse.org/). We strongly recommend Tidvyerse for data manipulation and visualization in R, and Pmetrics works well with it. See [R for Data Science](https://r4ds.hadley.nz) for more information.

### Model objects

You can specify a model by reading a file or directly as a list object in R. We'll do both.

The following code creates the same model as in `/src/model.txt` file. See further [model details](https://lapkb.github.io/Pmetrics/articles/models.html) on creating models in R compared to text files. The advantage of creating them in R is that one does not need to copy model files into folders to provide necessary inputs.

```{r}
#| label: mod1_def
#| eval: true
mod1 <- PM_model$new(
  pri = list(
    Ka = ab(0.1, 0.9),
    Ke = ab(0.001, 0.1),
    V = ab(30, 120),
    lag1 = ab(0, 4)
  ),
  cov = list(
    wt = interp(),
    africa = interp("none"),
    age = interp(),
    gender = interp("none"),
    height = interp()
  ),
  eqn = function(){
    two_comp_bolus
  },
  lag = function(){
    lag[1] = lag1
  },
  out = function(){
  Y[1] = X[2]/V
  },
  err = list(
    proportional(5, c(0.02, 0.05, -0.0002, 0))
  )
)
```

When you execute the above code in your own script or Quarto document, you will see a message indicating that the model has compiled.

```{r}
#| eval: true
mod1 # prints the model object
```

```{r}
#| eval: true
#| message: false

mod1$plot() # static plot so do not need to pipe to plotlygg() 
```

We have another file "model.txt" that contains the old representation of the same model we coded above, let's take a look at it.

```{r}
system("cat ../Examples/src/model.txt")
```

You can also open it in a text editor.

`PM_model$new()` also accepts the path to a model file to create the same model using the file.

```{r}
mod1b <- PM_model$new("../Examples/src/model.txt")
mod1b # look at it
```

PM_model provides a method to update the different elements of a model, for example:

```{r}
mod1b$update(
  pri = list(
    ka = ab(0.001, 5)
))
```

It is case sensitive, so ka is different from Ka. To remove a parameter, set it to NULL.

To copy a model use the \$clone() method.

```{r}
mod1b <- mod1$clone()
```

Simply using `mod1b <- mod1` will cause `mod1b` to be changed if `mod1` is changed, as R6 objects use reference semantics. For more details you can refer to \[Advanced R\] (https://adv-r.hadley.nz/r6.html), Section 14.4.

Lastly, Pmetrics has a model building app!

```{r}
build_model() #start from scratch
build_model(exData) #start with data to match covariates
build_model(mod1) #start with a model and update it
```

### Fit the model to the data

To keep everything tidy, we are working in a folder specifically to store the runs.

```{r}
#| label: change_Runs
#| eval: true
#| echo: false
wd <- getwd() # save the current working directory
knitr::opts_knit$set(root.dir = "../Examples/Runs") # change to the runs directory
```
```{r}
#| eval: true
run1 <- mod1$fit(data = exData, run = 1, overwrite = TRUE, report = "none") 
```

**Note:** We suppressed the report in this tutorial, but if you copy the code into your own script, you can see the html summary report that is generated at the end of a run by removing the `report = "none"` argument.

After the run is complete the results are returned to the assigned object, here 'run1'. However, if you want to load the results later, you can use the `PM_load()` function. Runs will be sequentially numbered as /1, /2, /3,... in your working directory.

```{r}
run1 <- PM_load(1) # load the results from run 1 if returning to this script later
```

```{r}
#| eval: true
#| echo: false
knitr::opts_knit$set(root.dir = wd) # return to the original working directory
```
### Examine the results

#### Data

You can plot the original data using R6 with various options. Type ?plot.PM_data in the R console for help.

```{r}
#| eval: true
run1$data$plot() %>% plotlygg() 
```

Remove the `%>% plotlygg()` portion in your own script or Quarto document to generate an interactive plot. Mouse over the points to get information. Try clicking one of the points to see what happens.

Here's some nice grouping and coloring. If you use grouping, provide names in `group_names` and colors/symbols for each group as arguments to `marker`. Colors of lines will be set to the same as for `marker` to avoid a mess of colors.

```{r}
#| eval: true
run1$data$plot(xlim = c(119, 146), group = "gender", group_names = c("Male", "Female"), 
  marker = list(color = c("red","blue"), symbol = c("circle","triangle-up"))) %>% plotlygg()
```

The next one splits the data by subject but will not render easily in this document. You can interact with it in your own script or Quarto document.

```{r}
run1$data$plot(overlay = FALSE, xlim = c(119, 145))
```

The following are the older S3 method with `plot(...)` for the first two examples. You can use R6 or S3 for any Pmetrics object. We will focus on R6 as the more modern way.

```{r}
plot(run1$data)
```

Here's a summary of the original data file; `?summary.PM_data` for help.

```{r}
run1$data$summary()
```

#### Observed vs. Predicted (OP)

You can plot observed vs. predicted data. Type `?plot.PMop` in the R console for help.

```{r}
#| eval: true
run1$op$plot() %>% plotlygg()
```

As always, remove the `%>% plotlygg()` portion in your own script or Quarto document to generate an interactive plot. Below, you can see how to change the prediction type, regression line and color, and plotting symbol and color. Most plots in Pmetrics have `marker` and `line` list arguments to customize the appearance of the plotting symbols and lines.

```{r}
run1$op$plot(pred.type = "pop")
run1$op$plot(line = list(lm = FALSE, loess = list(color = "red")), marker = list(symbol = 3, color = "green"))
```

Get a summary with bias and imprecision of the population predictions; `?summary.PMop` for help. The default `pred.type` is "post", which are the predictions based on the full Bayesian posterior distribution of parameter values for an individual. The predictions are the weighted mean or median (controlled by the `icen` argument in all Pmetrics functions) of the predictions from each support point in the individual's Bayesian posterior, joint probability parameter distribution, i.e. the support points in the posterior. Here we will look at the population predictions based on the means of the parameter values.

```{r}
run1$op$summary(pred.type = "pop", icen = "mean")
```

Since neither "pop" nor "mean" are the defaults, we have to specify them. We can also use the S3 method for the same summary below.

```{r}
summary(run1$op, pred.type = "pop", icen = "mean") # S3 method
```

As with any object in Pmetrics, the `PM_op` R6 object has fields and methods. Fields contain data and methods are functions that act on the data. All fields and methods are accessed with `$` added to the name of the object. For example, in a `PM_op` object and most other Pmetrics objects, the raw data can be accessed via the `$data` field.

```{r}
run1$op$data
```

Having the raw data provides a data frame compatible with any R function, particularly those from **Tidyverse** (see https://www.tidyverse.org/), including piping.

This allows pre-processing in ways more flexible than the default plot method.

```{r}
library(tidyverse)
run1$op$data %>% plot()
run1$op$data %>%
  filter(pred > 5) %>%
  filter(pred < 10) %>%
  summary()
```

See a header with the first 10 rows of the op object:

```{r}
head(run1$op$data, 10)
```

#### Final population joint density

Plot the final population joint density. Type `?plot.PM_final` in the R console for help.

```{r}
run1$final$plot()
```

You can add a kernel density curve.

```{r}
run1$final$plot(line = list((color = "red")))
#run1$final$data %>% plot() #this way will work too
```

It is possible to make a bivariate plot. Plotting formulae in R are of the form `y~x`

```{r}
run1$final$plot(ke ~ v,
  marker = list(color = "red", symbol = "diamond"))
```

The original final object can be accessed with the `$data` field.

```{r}
run1$final$data
names(run1$final$data)
```

See the population points:

```{r}
#| eval: true
run1$final$popPoints
```

Or drill down one more level into the raw data. The `$final$popPoints` field above pulls its information from the `$final$data$popPoints` field below, but is provided as a simpler way to access the population points.

```{r}
run1$final$data$popPoints
```

See the population mean parameter values:

```{r}
#| eval: true
run1$final$popMean
```

See a summary with confidence intervals around the medians and the Median Absolute Weighted Difference (MAWD); `?summary.PM_final` for help and further explanation.

```{r}
run1$final$summary()
```

#### Cycle information

Plot cycle information; type `?plot.PM_cycle` in the R console for help.

```{r}
run1$cycle$plot()
```

Summarize the cycle information; `?summary.PM_cycle` for help.

```{r}
run1$cycle$summary()
run1$cycle$data %>% summary()
```

Either one will work.

#### Covariate information

Plot covariate information; type `?plot.PM_cov` in the R console for help. Recall that plotting formulae in R are of the form `y~x`.

```{r}
run1$cov$plot(v ~ wt)
```

You can also use the raw data in the `$data` field to make plots with other R functions, including those from **Tidyverse**. Here we will filter the data for age \> 25 and then plot volume vs. weight.

```{r}
run1$cov$data %>%
  filter(age > 25) %>%
  plot(v ~ wt)
```

Change the formatting of the plot with the `line` and `marker` list arguments.

```{r}
run1$cov$plot(ke ~ age, line = list(loess = FALSE, lm = list(color = "red")),
               marker = list(symbol = 3))
```

Another plot with mean Bayesian posterior parameter and covariate values...remember the `icen` argument?

```{r}
run1$cov$plot(v ~ wt, icen = "mean")
```

When `time` is the `x` variable, the `y` variable is aggregated by subject. In R plot formulae, calculations on the fly can be included using the `I()` function.

```{r}
run1$cov$plot(I(v * wt) ~ time)
```

The above plots the product of volume and weight vs. time for each subject.

The previous cov object can be seen via `run1$cov`, which looks like a data frame, but is really an R6 `PM_cov` object whose `$print()` method returns a data frame. You can access the raw data with the `$data` field, which is truly a data frame.

```{r}
run1$cov$data[, 1:3] # for example
run1$cov$data %>% filter(gender == 1) %>% summary() # using Tidyverse
```

Just as you have the option to plot by mean covariate and posterior parameter values, you can summarize with means; `?summary.PM_cov` for help.

```{r}
run1$cov$summary(icen = "mean")
```

This returns a data frame with the means of the individual's covariates over the observation period and the mean of the Bayesian posterior parameter values.

When trying to find covariate-parameter relationships, it is convenient to examine at all possible covariate-parameter relationships by multiple linear regression with forward and backward elimination - type `?PM_step` in the R console for help.

```{r}
run1$step()
```

...or on the cov object directly.

```{r}
run1$cov$step()
```

`icen` works here too.

```{r}
run1$step(icen = "mean")
```

If you wish to see P values for forward elimination only:

```{r}
run1$step(direction = "forward")
```